1 - MISE EN PLACE DE L'ARBORESCENCE :

    A - CREATION D'UN REPERTOIRE "APP" A LA RACINE DU PROJET. (au mÃªme niveau qu'index.php).
        POURQUOI FAIRE ?

        Ce rÃ©pertoire a pour vocation de segmenter le projet web sur les axes FRONT & BACK :
        - D'un cÃ´tÃ© les ressources orientÃ©es client (Ã©galement nommÃ©es publiques)
        - De l'autre, les fichiers PHP responsables du bon fonctionnement de l'application (core).

        Index.php aura pour utilitÃ© de rÃ©quisitionner les ressources adÃ©quates en fonction 
        des paramÃ¨tres passÃ©s dans l'URL. On appelle Ã§a un routeur (mais ce sera Ã©tudiÃ© 
        plus tard.)

    B - CREATION DES REPERTOIRES "PUBLIC" & "CORE" DANS LE DOSSIER "APP".
        -> public : regrouper les ressources clientes (css, js, uploads, images, etc.)
                    ces ressources sont rÃ©parties sous forme de sous dossiers.

        -> core : regrouper le MVC (models, views, controllers)
                les composantes du MVC sont rÃ©parties sous forme de sous dossiers.

    C - A chaque nouveau projet PHP from scratch (rÃ©alisÃ© sans framework), 
        essayez (vraiment) de respecter cette nouvelle arborescence de fichiers.
        Ca fera la diffÃ©rence entre vous et les autres dÃ©veloppeurs. (dÃ©marquer)

2 - CONVERSION DU PROJET BASIQUE SOUS FORME D'ARCHITECTURE MVC :

    A - DECORTIQUAGE :

        1 - RAPPEL DE COURS : MVC segmente l'application en 3 composantes distinctes :
            -> Modeles : Tout ce qui a attrait aux intÃ©ractions avec une base de donnÃ©es.
            -> Vues : Toute ce qui est visible (globalement la partie HTML & boucles PHP)
            -> Controlleurs : L'aspect logique de l'application (contrÃ´le d'intÃ©gritÃ©,
                        et autres opÃ©rations sur les donnÃ©es tel que mise en minuscule, 
                        conversion en JSON, etc) ainsi que la mise en relation entre 
                        Modeles et Vues.

            Nous allons donc dÃ©cortiquer le projet fourni de sorte Ã  isoler ces 3 
            composantes.

        2 - MISE EN APPLICATION : 

            -> VUES : 
                    A - Ouvrir les fichiers "header.php", "footer.php" ainsi que "error.php".
                        Etudier ce qui les composent (Affichage ? Base de DonnÃ©es ? Logique ?)
                      
                        Il s'agit bel et bien de fichiers destinÃ©s Ã  l'affichae d'interface.
                        Ce sont donc des VUES.
                        De ce fait, on les dÃ©place Ã  la racine du rÃ©pertoire "views".

                    B - Ouvrir le fichier "all.php".
                        Etudier ce qu'il comporte (Affichage ? Base de DonnÃ©es ? Logique ?)
                        Effectivement, il comporte plusieurs choses : 
                            -> Affichage (lignes 1 Ã  6).
                            -> Base de donnÃ©es (lignes 8 Ã  29).
                            -> Affichage (lignes 31 Ã  62).
                        
                        Nous allons ainsi isoler la partie affichage de la page dans un fichier
                        situÃ© dans le rÃ©pertoire "views". 

                        /!/ Le nom du fichier dÃ©pend de la fonctionnalitÃ© qu'il offre.
                            De notre cÃ´tÃ© ce fichier permets l'affichage de TOUS les livres.
                            Il conviendra donc de le nommer : "all.php".

                        /!/ Les vues appartenant Ã  une mÃªme entitÃ© sont gÃ©nÃ©ralement 
                            regroupÃ©es au sein d'un rÃ©pertoire dÃ©diÃ© (dont le nom est 
                            identique Ã  celui de l'entitÃ©).
                            Dans notre cas, l'ensemble des vues associÃ©es aux "books"
                            seront regroupÃ©es dans un rÃ©pertoire intitulÃ© "book".
                        
                        Que reste t-il dans le fichier "all.php" duquel nous avons 
                        retirÃ© la partie VUES ? 
                        -> Il reste la partie en relation avec la Base de DonnÃ©es 
                           (que nous epxloiterons un tout petit peu plus tard).
                
                    C - Ouvrir le fichier "update.php".
                        Etudier ce qu'il comporte (Affichage ? Base de DonnÃ©es ? Logique ?)

                        Effectivement, il comporte un peu de tout : 
                            -> Logique (lignes 1 Ã  7) : regarder si le formulaire a Ã©tÃ© transmis.
                            -> Base de donnÃ©es (lignes 9 Ã  30).
                            -> Logique (lignes 35 Ã  42).
                            -> Affichage (lignes 43 Ã  56).
                            -> Logique (lignes 58 Ã  72).
                            -> Base de donnÃ©es (lignes 74 Ã  94).

                        Nous allons ainsi isoler la partie affichage de la page dans un fichier
                        situÃ© dans le rÃ©pertoire "views/book".

                        Pour nommer ce fichier, demandons nous Ã  quoi il sert.
                        Il s'agit d'un fomulaire de mise Ã  jour de donnÃ©es.
                        Ainsi, il pourrait s'intituler "update.php".
                    
                    D - Ouvrir le fichier "add.php".
                        Etudier ce qu'il comporte (Affichage ? Base de DonnÃ©es ? Logique ?)

                        Ce fichier comporte :
                        -> Affichage (lignes 1 Ã  13).
                        -> Logique (lignes 15 Ã  66). => avec un peu d'affichage traitÃ© + tard.
                        -> Base de donnÃ©es (lignes 67 Ã  84).

                        Nous allons ainsi isoler la partie affichage de la page dans un fichier
                        situÃ© dans le rÃ©pertoire "views/book".

                        Pour nommer ce fichier, demandons nous Ã  quoi il sert.
                        Il s'agit d'un fomulaire destinÃ© Ã  l'ajout de donnÃ©es.
                        Ainsi, il pourrait s'intituler "add.php".

                    E - Ouvrir le fichier "delete.php".
                        Etudier ce qu'il comporte (Affichage ? Base de DonnÃ©es ? Logique ?)

                        Ce fichier ne comporte pas d'affichage.
                        -> Logique + Base de DonnÃ©es.

                        Nous le traiteront ultÃ©rieurement.

            -> MODELES : 
            
                    A ce stade, l'application est cassÃ©e et c'est normal rassurez vous !
                    On va la remettre d'applomb trÃ¨s rapidement en effectuant la liaison 
                    entre les vues et le model. (pas encore avec le controlleur, 
                    ce sera pour plus tard).

                    La premiÃ¨re chose qu'il parait logique de faire est de rÃ©pliquer 
                    les Ã©tapes rÃ©alisÃ©es pour isoler les vues, sur la partie modeles.

                    RAPPEL DE COURS : La notion de MODEL fait rÃ©fÃ©rence Ã  tout ce qui a 
                    attrait aux intÃ©ractions avec une base de donnÃ©es.

                    A - Ouvrir le fichiers "dbConnect.php".
                        Etudier ce qui le composent (Affichage ? Base de DonnÃ©es ? Logique ?)
                      
                        Il s'agit bel et bien d'un fichier destinÃ© Ã  la connexion Ã  une BDD.
                        Il s'agit donc d'un MODELE.
                        De ce fait, on le dÃ©place Ã  la racine du rÃ©pertoire "models".
                    
                    B - Ouvrir le fichier "all.php".
                        
                        1 - Etudier ce qu'il en reste (Affichage ? Base de DonnÃ©es ? Logique ?)
                            Effectivement, il comporte : 
                            -> Base de donnÃ©es.
                        
                            Nous allons ainsi isoler cette partie BDD dans un fichier dÃ©diÃ©
                            situÃ© dans le rÃ©pertoire "models".

                            /!/ Jusqu'Ã  prÃ©sent nous avions pris l'habitude de crÃ©er un 
                            fichier par action.

                            L'approche MVC conseille de crÃ©er un fichier unique par entitÃ© 
                            dans lequel chaque action a vocation a Ãªtre contenue au sein 
                            d'une fonction.
                        
                            En d'autres termes : 
                            1 fichier = regroupement de TOUTES les actions d'une entitÃ©.

                            Le nom du fichier prend pour nom, le nom de l'entitÃ©. (au singulier)
                            Il est ensuite suffixÃ© par ce qu'il reprÃ©sente (Ã  savoir un model).
                            Le tout, en camelCase.

                            Dans notre cas, l'ensemble des actions associÃ©es aux "books"
                            seront regroupÃ©es dans un fichier intitulÃ© "bookModel".

                        2 - RESTE A CREER UNE FONCTION DONT LE CORPS EST STRICTEMENT 
                            IDENTIQUE A LA PARTIE BASE DE DONNEES DU FICHIER "ALL.PHP".

                            /!/ PAR CONVENTION, LE NOM DE CETTE FONCTION DOIT ETRE 
                            EQUIVOQUE A CE QU'ELLE PERMETS DE FAIRE.

                            Dans notre cas, nous la nommerons getAll() car elle a vocation
                            Ã  rÃ©cupÃ©rer l'ensemble des "books".
                            GET = recuperer + ALL = tous

                            /!/ Le chemin permettant de rÃ©quisitionner la connexion Ã  la 
                            BDD n'est plus cohÃ©rent : les deux sont aux mÃªme niveau.

                        3 - LIAISON DU MODEL A LA VUE :

                            C'est Ã  cet instant que les choses devraient de nouveau fonctionner.
                            Pour cela, il suffit de se rendre au sein de la vue intitulÃ©e "add.php"
                            puis de rÃ©quisitionner le model.

                            La rÃ©quisition du model dans la vue permet Ã  celle-ci 
                            d'exploiter n'importe quelle fonction contenue dans le model.

                            - La vue intitulÃ©e "all.php" a vocation a afficher l'ensemble
                            des "books". 
                            
                            - Les books sont rÃ©cupÃ©rables Ã  l'aide de la fonction getAll(), 
                            issue du model.

                            Il ne reste ainsi qu'Ã  faire usage de la fonction getAll() dans la 
                            vue intitulÃ©e "all.php" afin de rÃ©cupÃ©rer l'ensemble des books.

                            LE RESULTAT ISSU DE L'EXECUTION DE LA FONCTION GETALL() EST 
                            A STOCKER DANS LA VARIABLE SUR LAQUELLE L'ITERATION EST 
                            EFFECTIVE DANS LA VUE.
                            DE CE FAIT, ON STOCKE GETALL() DANS UNE VARIABLE $RESULTS.

                            MALHEUREUSEMENT CELA NE SUFFIT PAS :
                            La fonction getAll() ne retourne aucune donnÃ©e.
                            Il faut ainsi utiliser l'expression RETURN suivie de 
                            la variable qui contient les donnÃ©es afin de les rÃ©cupÃ©rer
                            lors de son appel, sur la vue.

                            /!/ RETURN s'utilise globalement lorsque l'on souhaite 
                            rÃ©cupÃ©rer / transmettre des donnÃ©es Ã  une vue.
                            On peut aussi l'utiliser afin de rÃ©cupÃ©rer le rÃ©sultat 
                            d'une execution afin de procÃ©der Ã  un traitement
                            suppÃ©lementaire dans le controlleur.

                        4 - SUPPRESSION DU FICHIER INITIAL : 
                            all.php (initial) est vide.
                            Afin d'Ã©viter de se mÃ©langer avec, un conseil : supprimez le.

                    C - Ouvrir le fichier "update.php".
                        
                        1 - Etudier ce qu'il en reste (Affichage ? Base de DonnÃ©es ? Logique ?)
                            Effectivement, il comporte : 
                            -> une premiÃ¨re partie logique.
                            -> une premiÃ¨re partie BDD.
                            -> une seconde partie logique.
                            -> une seconde partie BDD.

                            Nous allons ainsi isoler ces parties BDD dans le model, 
                            sous forme de deux fonctions distinctes.

                            POURQUOI DEUX FONCTIONS AU LIEU D'UNE SEULE QUI REGROUPE TOUT ?
                            -> Simplement car les deux parties "Base de donnÃ©es" qui 
                               composent le fichier "update.php" n'ont pas des finalitÃ©s
                               communes.

                               En effet, la 1Ã¨re partie BDD permet de : 
                               -> RÃ©cupÃ©rer les donnÃ©es du livre Ã  modifier 
                                  (afin de renseigner les champs sur la vue "update.php").
                             
                               La seconde partie BDD permet de : 
                               -> Mettre Ã  jour les informations du livre en base de donnÃ©es.
                                  (selon les datas rÃ©cupÃ©rÃ©es suite Ã  l'envoi du formulaire).

                        2 - CREATION DES FONCTIONS DANS LE MODEL :
                        
                            Au sein du MODEL, nous allons ainsi crÃ©er ces deux fonctions dont
                            les noms Ã©quivoques pourraient Ãªtres : 
                            -> getOne()
                            -> update()

                            Puis nous isolerons chaque partie BDD dans la fonction qui 
                            convient : 
                            -> getOne(){ // premiÃ¨re partie BDD // }
                            -> update(){ // seconde partie BDD // }

                            /!/ Les chemins permettants de rÃ©quisitionner la connexion Ã  la 
                            BDD ne sont plus cohÃ©rent : les deux sont aux mÃªme niveau.
                            Idem pour la redirection vers la vue des erreurs (MAJ le chemin)

                            /!/ C'est Ã  cet instant prÃ©cis qu'il convient de se poser la question 
                            suivante :
                            
                            PARMI LES FONCTIONS CREES, L'UNE D'ENTRE ELLE OU BIEN LES DEUX 
                            DOIT ELLE TRANSMETTRE DES DONNEES A UNE VUE ???

                            -> OUI ! getOne() interroge la base de donnÃ©es afin de rÃ©cupÃ©rer 
                                     l'ensemble des informations au sujet du livre Ã  modifier.

                            Ces informations sont ensuite affichÃ©es dans la VUE (dans 
                            les champs du formulaire de mise Ã  jour).

                            AINSI, IL CONVIENT DE RETOURNER LE RESULTAT DE LA REQUETE SQL
                            A L'AIDE DE L'EXPRESSION RETURN.

                            /!/ getOne() rÃ©cupÃ¨re les informations d'un livre en se basant sur 
                            l'identifiant du livre. Il est donc nÃ©cessaire de lui confier un 
                            paramÃ¨tre. ($bookID)

                            /!/ update() met Ã  jour un livre dans la base de donnÃ©es en se 
                            basant sur l'ensemble des donnÃ©es fournies par le formulaire.
                            Il est donc nÃ©cessaire de lui confier autant de paramÃ¨tre que 
                            le formulaire comporte de champs, en plus de l'identifiant 
                            (afin de mettre Ã  jour un livre prÃ©cisÃ©ment ciblÃ©).

                            
                            3 - LIAISON DU MODEL A LA VUE :

                            L'ultime Ã©tape consiste Ã  procÃ©der Ã  la liaison du MODEL et 
                            de la VUE afin de : 

                            -> Pouvoir afficher convenablement le formulaire 
                               d'Ã©dition (prÃ©-renseignÃ©)
                            -> ProcÃ©der Ã  la mise Ã  jour des donnÃ©es (suite Ã  
                               la transmission du formulaire).

                            Afin de prÃ©-renseigner le formulaire d'Ã©dition : 
                            -> RÃ©quisitionner le model sur la vue (update.php).
                            -> Faire appel Ã  la fonction getOne.
                            -> Passer en paramÃ¨tre, l'identifiant du livre ($_POST["updateID"])
                            -> Stocker le rÃ©sultat de getOne dans une variable. ($book)

                            Afin de procÃ©der Ã  la mise Ã  jour en base de donnÃ©es : 
                            -> Nous sommes bloquÃ©s (pour le moment).

                            POURQUOI ? 
                            CAR SUITE A L'ENVOI DU FORMULAIRE IL FAUDRAIT UNIQUEMENT 
                            EXECUTER LA FONCTION "UPDATE" ISSUE DU MODEL. (hors de n'est 
                            pas possible tel que nous nous y prenons).

                            Pour se dÃ©bloquer, cela demande d'aborder la notion de 
                            CONTROLLEUR (que nous Ã©tudierons trÃ¨s prochainement).

                    D - Ouvrir le fichier "add.php".
                        
                        1 - Etudier ce qu'il en reste (Affichage ? Base de DonnÃ©es ? Logique ?)
                            Effectivement, il comporte : 
                            -> Logique.
                            -> Base de DonnÃ©es.

                            Nous allons ainsi isoler la partie BDD dans le model, 
                            sous forme de fonction.

                        2 - CREATION DE LA FONCTION DANS LE MODEL :
                        
                            Au sein du MODEL, nous allons ainsi crÃ©er une fonction dont
                            le nom Ã©quivoque pourraient Ãªtre : add()
                            Puis nous isolerons la partie Base de DonnÃ©es Ã  l'intÃ©rieur.

                            /!/ Le chemin permettant de rÃ©quisitionner la connexion Ã  la 
                            BDD n'est plus cohÃ©rent.
                            Idem pour la redirection vers la vue "all.php" (MAJ le chemin)

                            /!/ C'est Ã  cet instant prÃ©cis qu'il convient de se poser la question 
                            suivante :
                            
                            LA FONCTION CREE DOIT ELLE TRANSMETTRE DES DONNEES A UNE VUE ???

                            -> NON ! Elle ne s'occupe "que" de procÃ©der Ã  l'ajout en base de donnÃ©es.
                                     Si l'on souhaite rÃ©cupÃ©rer des information sur l'execution de la 
                                     requÃªte, alors il peut Ãªtre intÃ©ressant de retourner celle-ci.

                                     De notre cÃ´tÃ©, nous n'allons pas le faire. (parce que OSEF)

                            /!/ add() ajoute un livre dans la base de donnÃ©es en se 
                            basant sur l'ensemble des donnÃ©es fournies par le formulaire.
                            Il est donc nÃ©cessaire de lui confier autant de paramÃ¨tre que 
                            le formulaire comporte de champs.

                        3 - LIAISON DU MODEL A LA VUE :
                            
                            Au mÃªme titre que pour la mise Ã  jour (update), nous sommes bloquÃ©s 
                            (pour le moment).

                            POURQUOI ? 
                            CAR SUITE A L'ENVOI DU FORMULAIRE IL FAUDRAIT UNIQUEMENT 
                            EXECUTER LA FONCTION "ADD" ISSUE DU MODEL. (hors de n'est 
                            pas possible tel que nous nous y prenons).

                            Pour se dÃ©bloquer, cela demande d'aborder la notion de 
                            CONTROLLEUR (que nous Ã©tudierons vraiment trÃ¨s prochainement).


                    D - Ouvrir le fichier "delete.php".
                        
                        1 - Etudier ce qu'il en reste (Affichage ? Base de DonnÃ©es ? Logique ?)
                            Effectivement, il comporte : 
                            -> Logique (2 Ã  3 lignes).
                            -> Base de DonnÃ©es (tout le reste).

                        2 - CREATION DE LA FONCTION DANS LE MODEL :
                        
                            Nom Ã©quivoque : delete()
                            Isoler la partie Base de DonnÃ©es Ã  l'intÃ©rieur.

                            /!/ Le chemin permettant de rÃ©quisitionner la connexion Ã  la 
                            BDD n'est plus cohÃ©rent.
                            Idem pour la redirection vers la vue "all.php" ainsi que
                            "error.php" (MAJ des chemins)

                            /!/ C'est Ã  cet instant prÃ©cis qu'il convient de se poser la question 
                            suivante :
                            
                            LA FONCTION CREE DOIT ELLE TRANSMETTRE DES DONNEES A UNE VUE ???

                            -> NON ! Elle ne s'occupe "que" de procÃ©der Ã  la suppression en BDD.

                            /!/ delete() supprime un livre de la base de donnÃ©es en se 
                            basant sur un identifiant.
                            Il est donc nÃ©cessaire de lui confier ce paramÃ¨tre ($bookID).

                        3 - LIAISON DU MODEL A LA VUE :
                            
                            Au mÃªme titre que pour la mise Ã  jour (update) et l'ajout (add), 
                            nous sommes bloquÃ©s (pour le moment).

                            POURQUOI ? 
                            CAR SUITE A LA SUPPRESSION D'UN LIVRE PASSE PAR L'ENVOI 
                            D'UN FORMULAIRE (voir la vue "all.php").
                            SUR CE FORMULAIRE IL FAUDRAIT UNIQUEMENT EXECUTER LA 
                            FONCTION "DELETE" ISSUE DU MODEL. (hors de n'est 
                            pas possible tel que nous nous y prenons).

                            Pour se dÃ©bloquer, cela demande d'aborder la notion de 
                            CONTROLLEUR (que nous allons Ã©tudier de maniÃ¨re imminente !!!).

                    /!/ AVANT DE POURSUIVRE SUR LES CONTROLLEURS :
                        DANS LE FICHIER INDEX : NE PAS OUBLIER DE METTRE A JOUR LES CHEMINS AFIN 
                        DE REQUISITIONNER LE HEADER ("app/core/views/header.php").

                        IDEM POUR L'ATTRIBUT HREF QUI PERMET DE REDIRIGER VERS LA VUE 
                        PERMETTANT D'AFFCIHER L'ENSEMBLE DES LIVRES ("app/core/views/book/all.php")

            -> CONTROLLEURS :

                Ã€ ce stade, notre application web ne fonctionne qu'Ã  moitiÃ© :

                    - Les vues s'affichent convenablement cependant, les formulaires qui y figurent sont 
                      inexploitables. (l'ajout, la suppression et la modification en base de donnÃ©e ne 
                      marche pas)

                    - Les liens qui permettent d'accÃ©der Ã  tel ou tel fichier sont aussi Ã  rallonge 
                      (ce qui est relou). En plus de trahir la faÃ§on dont a Ã©tÃ© concue notre application 
                      (sÃ©curitÃ©), on peut vite se tromper lorsque l'on souhaite accÃ©der Ã  un fichier en 
                      saisissant dans l'URL.

                C'EST DONC LE MOMENT DE RESOUDRE CES PROBLEMATIQUES EN ABORDANT LA NOTION DE CONTROLLEURS.

                THEORIE : 

                RAPPEL DE COURS : Les controlleurs permettent la mise en relation entre MODELES et VUES.
                                  Ã€ cÃ´tÃ© de cela, il permettent aussi de gÃ©rer l'aspect logique d'une partie 
                                  de l'application (contrÃ´le d'intÃ©gritÃ©, et autres opÃ©rations sur les 
                                  donnÃ©es tel que mise en minuscule, compter nb chars, conversion en JSON, etc)

                COMPLEMENT DE COURS : 
                    -> Un controlleur = 1 fichier que l'on crÃ©e par entitÃ©.
                    -> Le nom du controlleur est dÃ©fini par le nom de l'entitÃ© qu'il concerne puis suffixÃ© 
                    par le terme "controller" (le tout en camelCase).
                    Ex : Dans notre cas l'entitÃ© est "book", donc notre controlleur s'intitullera 
                    "bookController.php". (crÃ©er le fichier).

                    -> Chaque controlleur est constituÃ© de fonctions qui permettent de mettre 
                    en relation les modÃ¨les et vues d'une mÃªme entitÃ©.
                    Ex: Afin d'afficher l'ensemble des livres on pourrait imaginer que le bookControlleur 
                        contienne une fonction intitulÃ©e "showAll()".
                        Le corps de cette fonction mettrait ainsi en relation le model et la vue (all.php)
                        de l'entitÃ© "book" (puisque nous travaillerions sur le bookController).
                        COMMENT ? En y rÃ©quisionnant Ã  la fois le bookModel et la vue (all.php).
                        Au chargement de showAll(), le bookModel et la vue seraient ainsi chargÃ©s et tout 
                        fonctionnerait, en thÃ©orie, parfaitement.

                    -> Les controlleurs sont tous rÃ©pertoriÃ©s dans le dossier du mÃªme nom (Ã  l'exception du 
                    FRONT CONTROLLER que l'on place gÃ©nÃ©ralement Ã  la racine du rÃ©pertoire "public").

                    FRONT CONTROLLER ? (c'est quoi encore ce truc ?!! Rien de bien complexe)
                    -> C'est rÃ©ellement lui le chef d'orchestre de l'application.
                       En fonction des paramÃ¨tres passÃ©s dans l'URL du fichier "index.php" il : 
                       1 - RÃ©quisitionne le controlleur souhaitÃ©.
                       2 - Execute la fonction souhaitÃ©e issue du controlleur rÃ©quisitionnÃ©.
                       3 - Charge le tout sur le fichier index.php.

                    Exemple : index.php?controller=book&action=showAll
                    Va rÃ©quisitionner le "bookControlleur", Ã©xÃ©cuter la fonction qui y figure showAll().
                    Tel que dÃ©crit prÃ©cÃ©demment, cette fonction showAll() rÃ©quisitionnera elle mÃªme le 
                    "bookModel" ainsi que la vue (all.php).
                    Le tout sera ensuite chargÃ© sur la page index.php.

                    Ainsi vous l'aurez compris : l'application sera centralisÃ©e sur le fichier index.php.
                    Ce qui y sera affichÃ© (les vues) mais aussi les actions dÃ©pendront de paramÃ¨tres 
                    saisis dans l'URL.

                    En soit, c'est grÃ¢ce au FRONT CONTROLLER que nos URL seront un peu plus "simples".
                    POURQUOI ? Car nous n'aurons plus Ã  naviguer de rÃ©pertoire en rÃ©pertoire afin 
                    d'accÃ©der Ã  tel ou tel fichier : seulement de renseigner une URL avec paramÃ¨tres adÃ©quats.

                    Cette pratique permettra (ultÃ©rieurement )aussi de procÃ©der Ã  de la rÃ©-Ã©criture d'URL, 
                    c'est Ã  dire passer de quelque chose du genre : 

                    -> https://projet.test/index.php?controlleur=book&action=showAll 
                    -> https://projet.test/book/all

                    La rÃ©-Ã©criture d'URL comporte de nombreux avantages que nous dÃ©taillerons au cours 
                    de la sÃ©ance dÃ©diÃ©e.

                    /!/ Chaque projet MVC comporte un FRONT CONTROLLER et il est GLOBALEMENT IDENTIQUE
                        en tous points Ã  celui que nous concevrons tout Ã  l'heure.

                    /!/ IL EST A NOTER QUE LE FRONT CONTROLLER EST EGALEMENT PARFOIS NOMME : "ROUTEUR".
                        En considÃ©rant qu'une URL fait office de ROUTE permettant d'accÃ©der Ã  une ressource,
                        il est tout Ã  fait pertinent de le nommer de cette faÃ§on.

                    POUR RESUMER : 
                        -> Deux types de controlleurs : 
                            Controlleurs d'entitÃ© : met en relation les VUES & MODELES d'une entitÃ©.
                            Controlleur frontal : rÃ©quisitionne le controlleur d'entitÃ© adÃ©quat 
                                                  et execute la bonne fonction selon les paramÃ¨tres 
                                                  passÃ©s dans l'URL du fichier "index.php".

                        -> L'application sera centralisÃ©e sur le fichier "index.php", ce qui fournira
                           la possibilitÃ© de procÃ©der Ã  de la rÃ©Ã©criture d'URL (plus tard).

                    EN PRATIQUE : 

                    CrÃ©er le fichier "router.php" (FRONT CONTROLLER) dans Ã  la racine du rÃ©pertoire "public".
                    Si ce n'est pas encore fait, crÃ©er le fichier "bookController.php" au sein du rÃ©pertoire 
                    "app/core/controllers".

                    1 - LE CONTROLLEUR D'ENTITE (bookController) :

                        A - CREATION DES FONCTIONS D'INTERACTIONS : 

                        Afin de convenablement structurer les choses, nous allons y crÃ©er autant de fonctions
                        que d'intÃ©ractions prÃ©vues sur l'entitÃ© "book".

                        /!/ Le terme intÃ©raction dÃ©signe ici une fonctionnalitÃ© unique, prÃ©cise et 
                            surtout pouvant Ãªtre Ã©xÃ©cutÃ©e de faÃ§on indÃ©pendante.

                            Par exemple : ajouter un book ne correspond pas Ã  ces critÃ¨res.
                            En effet, l'ajout d'un book consiste en deux choses distinctes & indÃ©pendantes : 
                                1 - l'affichage d'un formulaire.
                                2 - l'insertion en base de donnÃ©es.

                        JUSTIFICATION APPROFONDIE :

                        1 - L'affichage d'un formulaire d'ajout peut Ãªtre effectuÃ© de maniÃ¨re indÃ©pendante,
                            c'est Ã  dire sur n'importe quelle page. (en complÃ©ment ou non d'autres contenus :
                            sous forme de composante).

                        2 - L'insertion en base de donnÃ©es dÃ©pend de la transmission du formulaire cependant,
                            elle ne dÃ©pend pas de la page sur laquelle se situe ce formulaire.
                            On raisonne dÃ©sormais en terme de fonctionnalitÃ©s indÃ©pendantes / composante et non plus 
                            en terme de fichiers. 

                        RÃ©flÃ©chissons donc quelques minutes Ã  ce que l'on envisage en terme de fonctionnalitÃ©s
                        indÃ©pendantes sur l'entitÃ© "book" :
                            -> Afficher l'ensemble des "books".
                            -> Afficher le formulaire d'ajout.
                            -> ProcÃ©der Ã  l'insertion de donnÃ©es (suite Ã  l'envoi du form d'ajout).
                            -> Afficher le formulaire de mise Ã  jour.
                            -> ProcÃ©der Ã  la mise Ã  jour des donnÃ©es (suite Ã  l'envoi du form d'update).
                            -> ProcÃ©der Ã  la suppression d'une donnÃ©e.

                        Donnons Ã  chacune de ces fonctionnalitÃ©s, un nom anglais Ã©quivoque puis crÃ©eons 
                        les fonctions vides associÃ©es (en respectant camelCase):

                            -> showAll() : Afficher l'ensemble des "books"
                            -> showAddForm() : Afficher le formulaire d'ajout.
                            -> insert() : ProcÃ©der Ã  l'insertion de donnÃ©es.
                            -> showUpdateForm() : Afficher le formulaire de mise Ã  jour.
                            -> update() : ProcÃ©der Ã  la mise Ã  jour des donnÃ©es.
                            -> delete() : ProcÃ©der Ã  la suppression d'une donnÃ©e.

                        /!/ Nous faisons ici face Ã  une limitation associÃ©e Ã  la programmation procÃ©durale.
                            En effet, le fichier "bookModel.php" dispose dÃ©ja des fonctions "update()" et 
                            "delete()". Ainsi il est fort probable de faire face Ã  un conflit en continuant
                            de la sorte, d'autant plus que le bookController va rÃ©quisitionner le bookModel 
                            afin d'effectuer les relations entre la partie BDD de l'app et les VUES.

                            De ce fait, il est prÃ©fÃ©rable de nommer diffÃ©remment "update()" et "delete()"
                            du "bookController" afin d'Ã©viter les conflits tel que : 
                                -> update() : refurbish()
                                -> delete() : drop()

                        B - LIAISON DU CONTROLLEUR D'ENTITE AVEC LE FICHIER INDEX.PHP (via FRONT CONTROLLER).
                            
                            Tel qu'Ã©voquÃ© en dÃ©but de sÃ©ance thÃ©orique sur les controllers, notre application 
                            MVC a vocation Ã  Ãªtre centralisÃ©e sur le fichier "index.php".
                            L'affichage de telle ou telle information sera donc effective selon 
                            diffÃ©rents paramÃ¨tres saisis dans l'URL. (controller & action)

                            Autant y passer maintenant : ce ne sera plus Ã  faire.

                            1 - Dans un premier temps, il convient de rÃ©quisitionner le fichier "routeur.php"
                                dans l'index (index.php).

                            2 - Au sein du fichier "router.php" nous allons ensuite respectivement procÃ©der au 
                                contrÃ´le de la prÃ©sence des paramÃ¨tres "controller" et "action" dans l'URL.

                                RAPPEL : LES PARAMETRES SITUES DANS L'URL SONT RECUPERABLES A L'AIDE DE LA 
                                         VARIABLE SUPERGLOBALE $_GET.

                                        if(isset($_GET["controller"])){}
                                        if(isset($_GET["action"])){}

                                /!/ PrÃ©voir l'Ã©ventualitÃ© selon laquelle AUCUN CONTROLLEUR / AUCUNE ACTION
                                    n'aurait Ã©tÃ© renseignÃ©e dans l'URL en initialisant deux variables tel que 
                                    prÃ©sentÃ© ci dessous : 

                                        $controller = "book";
                                        $action = "showAll";

                                Ainsi, quoi qu'il arrive si rien n'a Ã©tÃ© renseignÃ© la page ne restera pas vide.

                            3 - Au sein de chaque condition, remplacer la valeur de chaque variable 
                                initialisÃ©e par celles passÃ©es dans l'URL via $_GET.

                                        if(isset($_GET["controller"])){
                                            $controller = $_GET["controller"];
                                        }

                                        if(isset($_GET["action"])){
                                            $action = $_GET["action"];
                                        }
                            
                            4 - RÃ©quisition du controlleur d'entitÃ©.

                                Suite aux conditions, la rÃ©quisition du controlleur passÃ© en paramÃ¨tres 
                                s'effectue Ã  l'aide de l'expression "require_once" tel que :

                                        require_once("./app/core/controllers/".$controller."Controller.php");
                                
                                /!/ Le chemin fourni peut vous paraÃ®tre erronÃ© cependant, sachez que dÃ©sormais
                                    notre application se base sur le fichier "index.php".
                                    Il est donc logique de rÃ©quisitionner le controller depuis cet endroit.

                            5 - Execution de la fonction adÃ©quate.
                                
                                Ne reste qu'une ultime chose Ã  faire : Ã©xÃ©cuter la fonction du controlleur rÃ©quisitionnÃ©.
                                Pour cela : 
                                        
                                        $action();

                                Pour aller + loin, nous pourrions nous assurer que la saisie des paramÃ¨tres 
                                est conforme au type de donnÃ©es attendues (qu'il s'agit de texte, sans espaces,
                                en minuscule, etc.)


                            POUR RESUMER : 
                            La rÃ©quisition du "router.php" dans le fichier "index.php" permet de charger
                            automatiquement un controlleur et une action (selon les paramÃ¨tres saisis dans l'URL, 
                            sur la page index.) 
                            Au cas oÃ¹ aucun paramÃ¨tre n'a Ã©tÃ© communiquÃ©, un affichage de secours est prÃ©vu.
                            (via initialisation des variables $controller et $action).


                        C - LIAISON ENTRE LE CONTROLLEUR D'ENTITE ET LE MODEL ASSOCIE :

                            Tel qu'Ã©voquÃ© en dÃ©but de sÃ©ance thÃ©orique sur les controllers, ceux-ci font 
                            la liaison entre la partie MODELE d'une entitÃ© et les VUES associÃ©es.

                            Ainsi, nous allons rÃ©quisitionner le MODELE associÃ© Ã  l'entitÃ© sur laquelle nous 
                            travaillons (bookModel) sur le bookController.

                            /!/ Puisque notre application se base dÃ©sormais sur le fichier "index.php", 
                                la rÃ©quisition du "bookModel.php" doit Ã©galement Ãªtre effective depuis 
                                ce fichier.

                                En d'autres termes le chemin devrait Ãªtre le suivant :
                                require_once('./app/core/models/bookModel.php');
                        
                        D - REMPLISSAGE DU CORPS DES FONCTIONS DU BOOKCONTROLLER :

                            Afin de pouvoir exploiter notre bookControlleur, il reste Ã  renseigner 
                            le corps de chaque fonction.
                            
                            Pour chacune des fonctions il est impÃ©ratif de comprendre son usage ainsi que 
                            de se souvenir des VUES et fonctions du MODEL prÃ©cÃ©demment crÃ©Ã©.

                            1 - La fonction "showAll()" :
                                
                                Dans un premier temps, on se demande ce Ã  quoi sers cette fonction.
                                De part son nom, on en dÃ©duit assez facilement qu'elle a pour utilitÃ© 
                                l'affichage de l'ensemble des donnÃ©es au sujet d'une entitÃ©.

                                Comme depuis tout Ã  l'heure nous travaillons sur l'entitÃ© "book", 
                                showAll() permet donc d'afficher l'ensemble des "books".

                                Ainsi, il """suffit""" de renseigner dans le corps de showAll() tout ce qui 
                                permet d'afficher tous les livres.

                                QU'EST CE QUI PERMETS D'AFFICHER L'ENSEMBLE DES LIVRES ?

                                RÃ©ponse :
                                -> le fonction getAll() (issue du bookModel). 
                                   Qui permet d'aller chercher en base de donnÃ©es l'ensemble des books.

                                -> la vue (book/all.php).
                                   Qui exploite la fonction getAll() afin d'afficher sous forme de tableau HTML.

                                Ainsi, il ne reste qu'Ã  remplir le corps de la fonction showAll() de 
                                la faÃ§on suivante :

                                        function showAll(){
                                            $results = getAll();
                                            require_once('./app/core/views/book/all.php');
                                        }

                                /!/ Ce code fait doublon avec ce qui se trouve au tout dÃ©but de "all.php".
                                    De plus les chemins rÃ©quisitionnÃ©s ne sont plus cohÃ©rents sur la VUE.
                                    Etant donnÃ© que Ã§a fait doublon et que les chemins ne sont plus bons,
                                    Hop ! Autant supprimer ces instructions de la VUE (all.php).

                                EH VOILA ! CA DEVRAIT FONCTIONNER !
                                RESTE A ESSAYER D'ACCEDER A LA VUE QUI LISTE L'ENSEMBLE DES BOOKS VIA :

                                -> https://votre-domaine.test/index.php?controller=book&action=showAll

                            2 - La fonction "showAddForm()" :

                                Idem qu'au prÃ©alable : on se demande ce Ã  quoi sert cette fonction :
                                -> afficher le formulaire d'ajout.

                                Le formulaire d'ajout dÃ©pend-il d'autre chose ?
                                (ex: de donnÃ©es issues du model / base de donnÃ©es) ?
                                NON ! Il s'agit juste d'un formulaire classique. (une banale vue).

                                Dans ce cas, le corps de cette fonction ne comporte que la rÃ©quisition de 
                                la vue adÃ©quate telle que : 

                                        require_once('./app/core/views/book/add.php');

                                /!/ Au mÃªme titre que la vue prÃ©cÃ©demment traitÃ©e (all.php), 
                                le fichier "header.php" est rÃ©quisitionnÃ© Ã  deux reprises :
                                    -> sur le fichier index.php
                                    -> dans la vue ("add.php").

                                /!/ Ce code fait doublon.
                                    De plus le chemin rÃ©quisitionnÃ© sur la VUE est erronÃ©.
                                    Hop ! Autant supprimer cette instructions de la VUE (add.php).

                                EH VOILA ! CA DEVRAIT FONCTIONNER !
                                RESTE A ESSAYER D'ACCEDER A LA VUE QUI LISTE L'ENSEMBLE DES BOOKS VIA :

                                -> ./index.php?controller=book&action=showAddForm

                                /!/ C'est cette mÃªme URL qui sera Ã  spÃ©cifier pour accÃ©der au formulaire
                                    d'ajout depuis un lien.

                                    Mettons ainsi Ã  jour la valeur de l'attribut HREF du lien redirigeant
                                    vers la formulaire d'ajout, sur la VUE "book/all.php".

                            3 - La fonction "insert()" :

                                Idem qu'au prÃ©alable : on se demande ce Ã  quoi sert cette fonction :
                                -> InsÃ©rer des informations en BDD (recueillies du formulaire d'ajout).

                                Etant donnÃ© que ces informations proviennent du formulaire d'ajout, il est 
                                impÃ©ratif de lier ce formulaire Ã  l'action "insert()" du bookController.
                                Ainsi, lors de la soumission de celui-ci, les informations communiquÃ©es au 
                                bookController pourront Ãªtre insÃ©rÃ©es en base de donnÃ©es.

                                Dit comme Ã§Ã , Ã§a parrait compliquÃ© alors qu'en fait : pas du tout.

                                QUE POUVONS NOUS DEDUIRE DU FONCTIONNEMENT D'UN CONTROLLEUR D'ENTITE ?
                                    -> Le fait d'intÃ©rroger une URL (au sein de laquelle figurent 
                                       certains paramÃ¨tres) permet de rÃ©quisitionner un controlleur 
                                       et d'Ã©xÃ©cuter une de ses fonctions.
                                       
                                       Exemple : 
                                       -> https:// .... /index.php?controller=book&action=showAll
                                       -> Permet d'executer la fonction showAll() du bookController.

                                Sachant cela, on peut en dÃ©duire qu'appeler : 
                                    -> https:// .... /index.php?controller=book&action=insert
                                    -> Permettra d'executer la fonction insert() du bookController.
                                      (et possiblement d'insÃ©rer des informations en BDD suivant ce que 
                                      contient le corps de la fonction).

                                Selon cette dÃ©duction, la premiÃ¨re Ã©tape consite donc Ã  mettre Ã  jour 
                                la valeur de l'attribut "action" du formulaire d'ajout par l'URL qui 
                                permettra l'ajout en base de donnÃ©es.

                                Cette URL est la suivante : 
                                -> ./index.php?controller=book&action=insert

                                De ce fait, Ã  la soumission du formulaire d'ajout, la fonction insert() 
                                du bookController sera dÃ©sormais executÃ©e.
                                
                                RESTE A RENSEIGNER CONVENABLEMENT LE CORPS DE CETTE FONCTION : 

                                Pour cela, il faut dÃ©sormais se questionner sur ce qui permet l'ajout 
                                d'informations en Base de DonnÃ©es.

                                De souvenir, nous disposons d'une fonction dÃ©diÃ©e Ã  l'ajout de donnÃ©es 
                                au sein du bookModel.

                                /!/ Pour rappel cette fonction s'intitule "add()" et prends 3 paramÃ¨tres qui 
                                correspondent respectivement : 
                                    -> au titre
                                    -> Ã  la description
                                    -> au prix

                                On cherche donc Ã  rÃ©cupÃ©rer ces informations.

                                D'OÃ™ PROVIENNENT CES DONNEES ?
                                -> De la transmission du formulaire d'ajout !

                                Ainsi, d'un simple coup d'oeil, nous savons qu'elles transitent par mÃ©thode POST.
                                Pour rÃ©cupÃ©rer chaque donnÃ©es on exploite donc la variable globale $_POST.
                                
                                Suffit de passer ces donnÃ©es en paramÃ¨tres de la fonction "add()" et c'est gagnÃ©.
                                L'ajout devrait en thÃ©orie fonctionner.

                                        function insert(){
                                            add($_POST["titre"], $_POST["description"], $_POST["prix"]);
                                        }
                                
                                /!/ Au sein de la fonction "add()" (dans le bookModel), si l'execution se 
                                    dÃ©roule correctement, alors on redirige vers la VUE qui resence 
                                    l'ensemble des livres.

                                    SAUF QUE SUITE A NOS MANIPULATIONS, L'URL N'EST PLUS ADEQUATE.
                                    IL SERAIT SYMPA DE LA REMPLACER PAR :
                                    -> header('Location: ./index.php?action=showAll');

                                /!/ Profitons en pour rectifer toutes les URL inadÃ©quates du MODEL. ðŸ˜Ž

                                EH VOILA ! CA DEVRAIT FONCTIONNER !
                                GO TESTER EN ACCEDANT AU FORMULAIRE D'AJOUT !

                                /!/ Pour aller plus loin, il serait intÃ©ressant de contrÃ´ler la 
                                    rÃ©ception des donnÃ©es ainsi que leur intÃ©gritÃ©.

                                    Selon MVC, c'est au sein du CONTROLLEUR que s'effectuent 
                                    ces contrÃ´les (plus exactement dans la fonction insert()) tel que 
                                    prÃ©sentÃ© ci-aprÃ¨s : 

                                            function insert(){
                                                // ContrÃ´le d'envoi du formulaire (if(isset($_POST)))
                                                    // ContrÃ´le d'intÃ©gritÃ© des donnÃ©es ? //
                                                        // Si tout se passe bien :
                                                            add($_POST["titre"], $_POST["description"], $_POST["prix"]);
                                                        // Sinon 
                                                    // Fin du contrÃ´le d'intÃ©gritÃ©
                                                // Fin du contrÃ´le de rÃ©ception des donnÃ©es via POST
                                            }

                            4 - La fonction "drop()" :
                                    Idem qu'au prÃ©alable : on se demande ce Ã  quoi sert cette fonction :
                                    -> Supprimer un book de la BDD (en fonction d'un ID).

                                    L'action de suppression est lancÃ©e suite Ã  la soumission d'un 
                                    formulaire sur la VUE (book/all.php).

                                    On connaÃ®t par avance l'URL qui dÃ©clenchera cette suppression :
                                    -> ./index.php?controller=book&action=drop

                                    On se rend donc sur la VUE (book/all.php) et on met l'URL de l'action.

                                    L'action de suppression s'effectue Ã  l'aide d'une fonction provenant 
                                    du bookModel : "delete()"

                                    /!/ Cette fonction prends en paramÃ¨tre l'identifiant d'un book.
                                        Cet identifiant est rÃ©cupÃ©rÃ© via $_POST (suite Ã  l'envoi du form).

                                                function drop(){
                                                    delete($_POST["deleteID"]);
                                                }

                                EH VOILA ! CA DEVRAIT FONCTIONNER !
                                GO TESTER !
                                        

                            5 - AUX STAGIAIRES : 
                                Les fonctions showUpdateForm() et refurbish().

                                Correction : showUpdateForm()

                                On se rend donc sur la VUE (book/all.php) et on met l'URL de l'action.
                                -> ./index.php?controller=book&action=showUpdateForm

                                Le formulaire de mise Ã  jour est pre-renseignÃ©.
                                il est donc nÃ©cessaire de rÃ©cupÃ©rer les donnÃ©es du livre Ã  MAJ Ã  l'aide 
                                de la fonction getOne() issue du bookModel.

                                Puis de rÃ©quisitionner la VUE (update.php)
                                        function showUpdateForm(){
                                            $book = getOne($_POST["updateID"]);
                                            require_once('./app/core/views/book/update.php');
                                        }

                                /!/ Pour que Ã§a fonctionne, ne pas oublier de virer les redondances 
                                en haut de la vue (update.php) : require header, model & la variable = getOne.


                                Correction : refurbish()

                                Mettre Ã  jour l'URL de l'action du formulaire sur la VUE (update.php)
                                -> ./index.php?controller=book&action=refurbish

                                        function refurbish(){
                                            update($_POST["titre"], $_POST["description"], $_POST["prix"], $_POST["bookID"]);
                                        }


                            6 - On se rend compte que l'on a plus besoin du rÃ©pertoire webfiles :
                                Puisque l'application se situe dans le repertoire APP, plus besoin de webfiles
                                Du coup ... Hop ! Go le supprimer ! ðŸ˜Ž

                            7 - Conclusion : 
                                MVC fait intervenir une gymnastique d'esprit particuliÃ¨re.
                                Elle n'est pas forcÃ©ment Ã©vidente Ã  apprÃ©hender au dÃ©but, mais Ã  force 
                                de travailler avec, ce sera naturel (un peu comme Ã©crire de l'HTML il 
                                y a quelques mois VS aujourd'hui).

                                Les couches FRONT END et BACK END sont segmentÃ©es.
                                Ainsi un DEV FRONT peut bosser sans interfÃ©rer avec un DEV BACK et vice versa.


    Feuille de route globale : 
    - TOUJOURS COMMENCER PAR ISOLER LA PARTIE VUE (le code qui contient majoritairement de l'HTML).
    - POURSUIVRE AVEC L'ISOLATION DE LA PARTIE MODELE (le code qui contient la connexion Ã  la BDD + requetes)
    - FINALISER AVEC LE CONTROLLEUR (ce qui reste, on sais que ce sera dans le controlleur). 


    Exercies pour prendre en mains le MVC : 

    1 - Ajout d'une entitÃ© (users) Ã  l'application : possibilitÃ© de crÃ©er, modifier, supprimer, afficher des users.
    2 - CrÃ©ation d'un projet MVC (de zÃ©ro) sur un sujet thÃ¨me libre.
    3 - CrÃ©ation d'une plateforme de tchat en ligne faisant intervenir un MVC ProcÃ©dural (Groupe de 5).
